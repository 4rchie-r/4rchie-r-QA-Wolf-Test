// src/utils.ts
function S(e, t) {
  if (!e)
    throw new Error(t);
}
function u(e, t) {
  return typeof t === e;
}
function w(e) {
  return e instanceof Promise;
}
function f(e, t, n) {
  Object.defineProperty(e, t, n);
}
function l(e, t, n) {
  Object.defineProperty(e, t, { value: n });
}

// src/constants.ts
var y = Symbol.for("tinyspy:spy");

// src/internal.ts
var x = /* @__PURE__ */ new Set(), P = (e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, K = (e) => (f(e, y, { value: { reset: () => P(e[y]) } }), e[y]), T = (e) => e[y] || K(e);
function I(e) {
  S(
    u("function", e) || u("undefined", e),
    "cannot spy on a non-function value"
  );
  let t = function(...o) {
    let r = T(t);
    r.called = !0, r.callCount++, r.calls.push(o);
    let R = r.next.shift();
    if (R) {
      r.results.push(R);
      let [s, m] = R;
      if (s === "ok")
        return m;
      throw m;
    }
    let p, c = "ok", a = r.results.length;
    if (r.impl)
      try {
        new.target ? p = Reflect.construct(r.impl, o, new.target) : p = r.impl.apply(this, o), c = "ok";
      } catch (s) {
        throw p = s, c = "error", r.results.push([c, s]), s;
      }
    let g = [c, p];
    return w(p) && p.then(
      (s) => r.resolves[a] = ["ok", s],
      (s) => r.resolves[a] = ["error", s]
    ), r.results.push(g), p;
  };
  l(t, "_isMockFunction", !0), l(t, "length", e ? e.length : 0), l(t, "name", e && e.name || "spy");
  let n = T(t);
  return n.reset(), n.impl = e, t;
}
function A(e) {
  let t = T(e);
  "returns" in e || (f(e, "returns", {
    get: () => t.results.map(([, n]) => n)
  }), [
    "called",
    "callCount",
    "results",
    "resolves",
    "calls",
    "reset",
    "impl"
  ].forEach(
    (n) => f(e, n, { get: () => t[n], set: (o) => t[n] = o })
  ), l(e, "nextError", (n) => (t.next.push(["error", n]), t)), l(e, "nextResult", (n) => (t.next.push(["ok", n]), t)));
}

// src/spy.ts
function V(e) {
  let t = I(e);
  return A(t), t;
}

// src/spyOn.ts
var k = (e, t) => Object.getOwnPropertyDescriptor(e, t), O = (e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
};
function C(e, t, n) {
  S(
    !u("undefined", e),
    "spyOn could not find an object to spy upon"
  ), S(
    u("object", e) || u("function", e),
    "cannot spyOn on a primitive value"
  );
  let [o, r] = (() => {
    if (!u("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), R = k(e, o), p = Object.getPrototypeOf(e), c = p && k(p, o), a = R || c;
  S(
    a || o in e,
    `${String(o)} does not exist`
  );
  let g = !1;
  r === "value" && a && !a.value && a.get && (r = "get", g = !0, n = a.get());
  let s;
  a ? s = a[r] : r !== "value" ? s = () => e[o] : s = e[o];
  let m = (d) => {
    let { value: h, ...v } = a || {
      configurable: !0,
      writable: !0
    };
    r !== "value" && delete v.writable, v[r] = d, f(e, o, v);
  }, b = () => a ? f(e, o, a) : m(s);
  n || (n = s);
  let i;
  if (s && y in s)
    i = s;
  else {
    i = I(n), r === "value" && O(i, s);
    let d = i[y];
    l(d, "restore", b), l(d, "getOriginal", () => g ? s() : s), l(d, "willCall", (h) => (d.impl = h, i));
  }
  return m(
    g ? () => (O(i, n), i) : i
  ), x.add(i), i;
}
function Q(e, t, n) {
  let o = C(e, t, n);
  return A(o), ["restore", "getOriginal", "willCall"].forEach((r) => {
    l(o, r, o[y][r]);
  }), o;
}

// src/restoreAll.ts
function X() {
  for (let e of x)
    e.restore();
  x.clear();
}
export {
  I as createInternalSpy,
  T as getInternalState,
  C as internalSpyOn,
  X as restoreAll,
  x as spies,
  V as spy,
  Q as spyOn
};
